---
title: "Pollution model"
output: html_notebook
---

```{r libraries, warning=FALSE, message=FALSE}
library(deSolve)
# library(deTestSet)
library(tidyverse)
```
Updated version (J200925) with the current notation of the paper

$$\forall{i} \in\{1,...,n\}; \frac{dx_i}{dt} = u_i - s_ix_i + v_i \frac{x_{i}^{\alpha_{i}}}{z_i^{\alpha_{i}} + x_{i}^{\alpha_{i}}} 
- \sum_{j \neq i} (\delta_{ij}x_i - \delta_{ji}x_j)$$

Notice that the second term can be factorized and extract $\delta_{ij}$ in matrix form and simply multiply by the difference $(x_i - x_j)$.

```{r}

# This is where we define your event function
# Add this directly above your call to ode()
posfun <- function(t, y, parms){
  with(as.list(y), {
    y[which(y<0)] <- 0
    return(y)
  })
}

## Pollution model:

pollution <- function(t, y, params){
  with(as.list(c(y, params)), {
    x = y
    pollutant <- u - s*x + v * (x^alpha/(z^alpha + x^alpha))
    outflow <-  delta_ij %*% x
    inflow <-  t(delta_ij) %*% x

    dy <- pollutant + (inflow - outflow)
    
    return(list(c(dy)))
  })
}

## set up flux matrix
n <- 4
#delta_ij <- matrix(runif(n^2, min = 0.02, max = 0.05), ncol = n)
delta_ij <- matrix(rep(0,n^2), ncol = n) # turn off difussion
diag(delta_ij) <- 0

## Parameters: use rep() if the value is the same, or runif() ir meant to be different across systems
params <- list(
    u = rep(1.5, n),              # pollution load from humans
    s = rep(0.4, n),              # internal loss rate (sedimentation)
    v = rep(2, n),                # max level of internal nutrient release
    z = runif(n, min = 2, max = 8),        # threshold
    alpha = 4 ,                   # sharpness of the shift
    delta_ij = delta_ij           # adjacency matrix of difussion terms
)

## set up time steps
times <- seq(from = 0, to = 100, by = 0.01)

## initial conditions
yini <- runif(n, 5, 20)

## run the model
print(system.time(
    out <- ode(
      y = yini, times = times,  func = pollution, parms = params,
      method = "bdf" , ## see help("ode") for more methods
      events=list(func = posfun, time = times)
    )
))

```
Model with no connections:

```{r warning = FALSE, message = FALSE}
df <- out %>% as_tibble() %>%
    gather(key = "species", value = "population", 2:last_col())

df %>%
    ggplot(aes(x=time, y=population)) +
    geom_line(aes(color = species), size = 0.25, show.legend = T) + 
    theme_light()
```

Connected model: 

```{r warning = FALSE, message = FALSE}
## set up flux matrix
delta_ij <- matrix(runif(n^2, min = 0.02, max = 0.05), ncol = n)
diag(delta_ij) <- 0

## Only change the delta:
params$delta_ij <-  delta_ij           # adjacency matrix of difussion terms

## run the model
out <- ode(
  y = yini, times = times,  func = pollution, parms = params,
  method = "bdf", ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)


df <- out %>% as_tibble() %>%
    gather(key = "species", value = "population", 2:last_col())

df %>%
    ggplot(aes(x=time, y=population)) +
    geom_line(aes(color = species), size = 0.25, show.legend = T) + 
    theme_light()
```



## Normalized model:

$$  
\frac{dX_i}{d\tau} =U_i-X_i+V_i\frac{X_i^{\alpha_i}}{1+X_i^{\alpha_i}}+\sum_{j\not=i}\Delta_{ij}(Z_{ij}X_j-X_i)
$$

Where $X_i=\frac{x_i}{z_i}$, $\frac{dt}{d\tau}=\frac{1}{s_i}$, $U_i=\frac{u_i}{s_iz_i}$, $V_i=\frac{v_i}{s_iz_i}$, $Z_{ij}=\frac{\delta_{ji}z_j}{\delta_{ij}z_i}$ and $\Delta_{ij}=\frac{\delta_{ij}}{s_i}$. 

```{r}
Zetify <- function(D,z) {
  # D is the adjacency matrix with difussion coefficients delta_ij
  # z is the vector of threshods z_i
  Z <- matrix(nrow = nrow(D), ncol = ncol(D))
  for (i in 1:nrow(D)){
    for(j in 1:ncol(D)){
      Z[i,j] = (D[j,i] * z[j]) / (D[i,j] * z[i])
    }
  }
  #diag(Z) <- 0
  return(Z)
}
```


```{r}
# test
with(params, Zetify(delta_ij, z))
# which is different from:
params$delta_ij %*% params$z
# and from:
params$z %*% params$delta_ij
# so it's not equivalent to vector matrix multiplication. But it is equivalent to the expression below, except the diagonal.
with(params, t(delta_ij * z)) / with(params, (delta_ij) * z) == with(params, Zetify(delta_ij, z))
```
```{r}
# little profiling:
library(tictoc)
tic()
with(params, Zetify(delta_ij, z))
toc()

tic()
with(params, t(delta_ij * z)) / with(params, (delta_ij) * z)
toc()

# equally fast :)
```


```{r warning = FALSE, message = FALSE}
## Pollution model
pollution_norm <- function(t, y, params){
  with(as.list(c(y, params)), {
    x = y
    ## Normalization steps:
    X = x/z
    U = u/(s*z)
    V = v/(s*z)
    Zij_parts <- delta_ij * z
    Zij = t(Zij_parts) / Zij_parts ## the same as lower triangle / upper triangle and viceversa
    ## the next line corrects the case when Zij is NaN induced by division by zero. In that case, Zij should be a matrix full of zeroes = no connections.
    if(all(is.nan(Zij))) Zij = Zij_parts
    
    # set diag to zero
    diag(Zij) <- 0
    Delta_ij = delta_ij / s
    
    ## System with normalized parameters
    pollutant <- U - X + V * (X^alpha/(1 + X^alpha))
    outflow <-  (Delta_ij * Zij) %*% X
    inflow <-  t(Delta_ij) %*% X # Zij is not multiplied by Delta_ij by suggestion of ASC.

    dX <- pollutant + (inflow - outflow)
    
    return(list(c(dX)))
  })
}



## run the model
out <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  method = "bdf", ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)


df <- out %>% as_tibble() %>%
    gather(key = "species", value = "population", 2:last_col())

df %>%
    ggplot(aes(x=time, y=population)) +
    geom_line(aes(color = species), size = 0.25, show.legend = T) + 
    theme_light()

```

## To-do:

1. Systems without connections: Now with a working model, update and change some parameters.
```{r warning=FALSE, message=FALSE}
# delta_ij # old delta_ij used in previous runs
## Turn-off the connection
params$delta_ij <- matrix(rep(0, n^2), n, n)

## run the model
out <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  #method = "bdf" ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)


out %>% as_tibble() %>%
    gather(key = "system", value = "pollutant", 2:last_col()) %>%
    ggplot(aes(x=time, y=pollutant)) +
    geom_line(aes(color = system), size = 0.25, show.legend = T) + 
    theme_light()
```



2. Systems with connections (max 10)

I first update N to 10 and create initial conditions for all systems. For comparison I run a model without connection, and then turn on difussion. 

```{r warning=FALSE, message=FALSE}
## I need to update all parameters then:
## set up flux matrix
n <- 10
#delta_ij <- matrix(runif(n^2, min = 0.02, max = 0.05), ncol = n)
delta_ij <- matrix(rep(0,n^2), ncol = n) # turn off difussion
diag(delta_ij) <- 0

## Parameters: use rep() if the value is the same, or runif() ir meant to be different across systems
params <- list(
    u = rep(1.5, n),              # pollution load from humans
    s = rep(0.4, n),              # internal loss rate (sedimentation)
    v = rep(2, n),                # max level of internal nutrient release
    z = runif(n, min = 2, max = 8),        # threshold
    alpha = 4 ,                   # sharpness of the shift
    delta_ij = delta_ij           # adjacency matrix of difussion terms
)

## initial conditions
yini <- runif(n, 5, 20)
## run the model
out <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  #method = "bdf" ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)

## Visualize
out %>% as_tibble() %>%
    gather(key = "system", value = "pollutant", 2:last_col()) %>%
    ggplot(aes(x=time, y=pollutant)) +
    geom_line(aes(color = system), size = 0.25, show.legend = T) + 
    theme_light()
```

Note that currently the $\delta_{ij}$ matrix has low diffusion coefficients (2-5%) but all lakes are connected to each other. To better control structure, one should multiply the difussion coefficents to a [0,1] adjacency matrix, so one gets control of structure on a term by itself.

```{r warning = FALSE, message=FALSE}
## get a erdos-renyi random graph
Aij <- igraph::sample_gnp(n, 0.2, TRUE) %>% 
  igraph::as_adjacency_matrix(graph = .) %>% 
  as.matrix()

## activate conections
delta_ij <- matrix(runif(n^2, min = 0.02, max = 0.05), ncol = n)
diag(delta_ij) <- 0
params$delta_ij <- delta_ij

## run the model
out <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  #method = "bdf" ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)

# Visualize
out %>% as_tibble() %>%
    gather(key = "system", value = "pollutant", 2:last_col()) %>%
    ggplot(aes(x=time, y=pollutant)) +
    geom_line(aes(color = system), size = 0.25, show.legend = T) + 
    theme_light()
```

3. Scenario when Z_ij > 1 vs. Z_ij < 1

Because $Z_{ij}=\frac{\delta_{ji}z_j}{\delta_{ij}z_i}$ and $z_i = z_j$, the only way to control $Z$ in a way that it becomes >1 or <1 depends on $\delta_{i,j}$. The matrix needs to be created with the upper triangle > lower triangle or viceversa.

```{r warning = FALSE, message=FALSE}
## This makes sure that Z_ij > 1
delta_ij <- matrix(0, ncol = n, nrow = n)
delta_ij[upper.tri(delta_ij) ] <-  0.02
delta_ij[lower.tri(delta_ij) ]<- 0.05

params$delta_ij <- delta_ij

## run the model
out <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  #method = "bdf" ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)

## This makes sure that Z_ij > 1
delta_ij <- matrix(0, ncol = n, nrow = n)
delta_ij[upper.tri(delta_ij) ] <-  0.05
delta_ij[lower.tri(delta_ij) ]<- 0.02

params$delta_ij <- delta_ij

## run the model
out2 <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  #method = "bdf" ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)

out <- out %>% as_tibble() %>%
  gather(key = "system", value = "pollutant", 2:last_col()) %>%
  add_column(scenario = "Z > 1") %>%
  mutate(time = as.numeric(time), pollutant = as.numeric(pollutant))
  
out2 <- out2 %>% as_tibble() %>%
  gather(key = "system", value = "pollutant", 2:last_col()) %>%
  add_column(scenario = "Z < 1") %>% 
  mutate(time = as.numeric(time), pollutant = as.numeric(pollutant))

# Visualize
full_join(out,out2) %>% 
    ggplot(aes(x=time, y=pollutant)) +
    geom_line(aes(color = system), size = 0.25, show.legend = T) + 
  facet_wrap(~scenario) +
    theme_light()
```
However, not all $Z_{ij}$ are >1 or < 1. 

```{r}
zmat <- with(params, delta_ij * z)
(t(zmat)/zmat) > 1
```

The reason for that is that it depends also of $z_i$ on the original equation. The only way to control for that is to constructing $z$ by hand, or making it the same for all systems.

4. Scenario when $\Delta_ij > 1$ versus $\Delta_{ij} < 1$

```{r warning = FALSE, message=FALSE}
## reset delta_ij
delta_ij <- matrix(runif(n^2, min = 0.02, max = 0.05), ncol = n)
diag(delta_ij) <- 0
params$delta_ij <- delta_ij

## By setting s to > min value of delta, the matrix is >=1 always
params$s <- 0.015

## run the model
out <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  #method = "bdf" ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)

## This makes sure that Z_ij > 1
## By setting s to > max value of delta, the matrix is <= 1 always
params$s <- 0.07

## run the model
out2 <- ode(
  y = yini, times = times,  func = pollution_norm, parms = params,
  #method = "bdf" ## see help("ode") for more methods
  events=list(func = posfun, time = times)
)

out <- out %>% as_tibble() %>%
  gather(key = "system", value = "pollutant", 2:last_col()) %>%
  add_column(scenario = "Z > 1") %>%
  mutate(time = as.numeric(time), pollutant = as.numeric(pollutant))
  
out2 <- out2 %>% as_tibble() %>%
  gather(key = "system", value = "pollutant", 2:last_col()) %>%
  add_column(scenario = "Z < 1") %>% 
  mutate(time = as.numeric(time), pollutant = as.numeric(pollutant))

# Visualize
full_join(out,out2) %>% 
    ggplot(aes(x=time, y=pollutant)) +
    geom_line(aes(color = system), size = 0.25, show.legend = T) + 
  facet_wrap(~scenario) +
    theme_light()
```

5. Test for structural stability before running simulations
6. Repeat for resource system.
7. Set up controlling experiments

Notes after meeting with ASC: 
> - fix the $A_{ij}$, the model was not updated
> - extract results and create a graph with scenarios when Z and Delta are >1<
> - phase diagrams X vs U?
